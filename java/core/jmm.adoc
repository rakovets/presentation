= Java Memory Management

== Intro

=== Размер объекта

[.fragment]
JVM хранит для каждого объекта:

[.step]
* Заголовок объекта;
[.step]
** 8 байт (32-х разрядная ОС)
** 16 байт (64-х разрядная ОС)
* Память для примитивных типов;
* Память для ссылочных типов;
* Смещение/выравнивание

=== Размер объекта

[.fragment]
[source,java]
----
int i = 25; // размер примитива
Integer b = 25; // размер(reference) + размер примитива (int)
----

=== Размер объекта

[.step]
* *Заголовок*: 16 байт
* *Поле* `int`: 4 байта
* *Выравнивание для кратности 8*: 4 байта
* *Итого*: 24 байта

== GC

=== GC

[.step]
* Объекты создаются динамически с помощью операции `new`, а уничтожаются автоматически.
* Когда никаких ссылок на объект не существует (все ссылки на него вышли из области видимости программы) предполагается, что объект больше не нужен, и память, занятая объектом, может быть освобождена.
* *Сборка мусора* происходит нерегулярно во время выполнения программы. Рекомендовано ее выполнить вызовом метода `System.gc()` или `Runtime.getRuntime().gc()`.


=== GC

[.step]
* Вызов метода `System.runFinalization()` приведет к запуску метода `finalize()`  для объектов утративших все ссылки.
* В Java пересмотрена концепция *динамического распределения памяти*: _отсутствуют способы освобождения динамически выделенной памяти_. Вместо этого реализована система автоматического освобождения памяти (*сборщик мусора*), выделенной с помощью оператора `new`.
* *Сборщик мусора* уничтожает объекты, которым не соответствует ни одна ссылка из активного потока.

=== GC

[.step]
* Аналогом деструктора можно считать метод `finalize()`, который исполняющая среда языка Java будет вызывать каждый раз, когда сборщик мусора будет уничтожать объекты этого класса.
* *Сборщиком мусора* — специальный процесс периодически освобождает память, удаляя объекты, которые уже не будут востребованы приложениями — то есть производит *сбор мусора*.
